# Programa de estudio de la UNO
>Originalmente creé esto como una breve lista de tareas pendientes para obtener un título en Licenciatura en Informática, pero creció hasta llegar a la gran lista que se ve hoy en día.
>
>Los elementos enumerados aquí te preparan en teoría para ser un Licenciado en Informática.
>
>*¡La mejor de las suertes para ti!*

Traducciones:
- [Ingles](./README.md)


# Tabla de contenido
- [¿Qué es esto?](#qué-es-esto)
- [¿Por qué usarlo?](#por-qué-usarlo)
- [Como usarlo](#como-usarlo)
- [No sienta que no es lo suficientemente capaz](#no-sienta-que-no-es-lo-suficientemente-capaz)
- [Lo que necesita saber](#lo-que-necesita-saber)
- [Descripción de la Carrera](#descripcion-de-la-carrera)
- [Universidad vs. Realidad](#universidad-vs.-realidad)
- [Antes de iniciar](#antes-de-iniciar)
* Primer Año
  - [Algoritmos y Estructura de Datos](#algoritmos-y-estructura-de-datos)
  - Tecnología Aplicada
  - Algebra y Geometría Analítica
  - Teoría de Sistemas y Organizaciones
  - Matemática Discreta
  - Programación con Objetos I (Correlativa de Algoritmos)
  - Arquitectura de Computadores I (Correlativa de Tecnología Aplicada)
* Segundo Año
  - Análisis Matemático I (Correlativa de Algebra)
  - Probabilidad y Estadística (Correlativa de Análisis Matemático I)
  - Base de Datos I (Correlativa de Algoritmos y Matemática Discreta)
  - Programación con Objetos II (Correlativa de Programación con Objetos I)
  - Sistemas Operativos I ( Correlativa de Arquitectura de Computadores I)
  - Ingeniería de Software (Correlativa de Teoría de Sistemas)
  - Lenguajes Formales (Correlativa de Matemática Discreta)
  - Arquitectura de Computadores II (Correlativa de Arquitectura de Computadores I)
  - Comunicación y Redes I (Correlativa Arquitectura de Computadores I)
* Tercer Año
  - Análisis Matemático II (Correlativa de Análisis Matemático I)
  - Matemática Aplicada (Correlativa de Análisis Matemático II)
  - Comunicación y Redes II (Correlativa de Redes I)
  - Taller de Redes (Correlativa de Redes II)
  - Sistemas Operativos II (Correlativa de Arquitectura de Computadores y Sistemas Operativos I)
  - Programación con Objetos III (Correlativa de Programación con Objetos II, Sistemas Operativos I y Base de Datos II)
  - Interfaces de Usuario y Tecnologías Web (Correlativa de Programación con Objetos II)
  - Base de Datos II (Correlativa de Base de Datos I y Sistemas Operativos I)
  - Explotación de Datos (Correlativa de Base de Datos II)
  - Ingeniería de Software II (Correlativa de Ingeniería de Software I)
* Cuarto año
  - Modelos, Simulación y Teoría de la Decisión (Correlativa de )
  - Dirección y Evaluación de Proyectos Informáticos (Correlativa de)
  - Arquitectura de Software III (Correlativa de )
  - Paradigmas de Programación (Correlativa de)
  - Lenguajes de Programación (Correlativa de)
  - Infraestructura de Sistemas (Correlativa de)
  - Desarrollo de Compiladores (Correlativa de)
  - Inteligencia Artificial (Correlativa de )
  - Practica Profesional (Correlativa de)
* Quinto Año
  - Ingeniería de Software III (Correlativa de )
  - Sistemas de Tiempo Real y Misión Critica (Correlativa de )
  - Seguridad y Auditoria (Correlativa de )
  - Teoría de la computación (Correlativa de )
  - Trabajo Final

---

# ¿Qué es esto?

Este es el plan de estudio de varios meses de UNO para terminar el Grado en Ciencias de la Computación, obteniendo un título en Analista de Sistemas en el medio de la carrera.

Esto es para los **nuevos estudiantes de la UNO**, aquellos que quieren aprender que tipo de contenido se ve en una Universidad de este estilo o por lo menos quieren usar esto de guiá. Si tiene varios años de experiencia y calma tranquilo esto puede llevar tiempo.


# ¿Por qué usarlo?

Cuando comencé este proyecto, no sabía la diferencia entre un stack y un heap, no conocía la notación Big-O, nada acerca de árboles, ni cómo sacar la transversal de una gráfica. Si tenía que programar un algoritmo de clasificación, puedo decir que no hubiera sido muy bueno. Cada estructura de datos que había utilizado estaba incorporada al lenguaje, y yo no sabía cómo funcionaban realmente. Yo nunca tuve que manejar la memoria a menos que un proceso que yo estaba corriendo diera un error de “out of memory”, y tenía que encontrar una alternativa. He usado pocos arreglos de varias dimensiones en mi vida y miles de arreglos asociativos, pero nunca he creado estructuras de datos desde cero.

Si mucho de esto te resulta familiar entonces te tomará mucho menos tiempo.

Es un plan largo, puede tome unos meses; pero si le resulta familiar mucho de esto le tomara mucho menos tiempo.

# Como usarlo

Todo lo que aparece abajo es un plan, y debería abordar los elementos en orden de arriba a abajo.

Estoy usando el tema especial de markdown de Github, incluyendo listas de tareas para comprobar el progreso.

## Cree una nueva rama para que pueda validar elementos como este, solo ponga una x en los corchetes:
### Usando git:
>
>    Haga fork a una rama y siga los comandos siguientes


>`git checkout -b progress`

>`git remote add Phosphorus-M https://github.com/Phosphorus-M/Study-program-of-the-UNO-Universidad-Nacional-del-Oeste-`

>`git fetch --all`

Marque todas las cajas con una x después de que completa los cambios

>`git add . `

>`git commit -m "Marked x" `

>`git rebase Phosphorus-M/master `

>`git push --force `


### Cree una rama usando Github:
Al lado del nombre del repositorio saldrán 3 opciones.
>Watch
>Star
>Fork

Usted deberá hacer click en *Fork*.
Inmediatamente saldrá una ventana diciéndole:
>Where should we fork this repository?

Usted deberá seleccionar su cuenta
La rama se hará automaticamente y usted lo único que deberá hacer para validar los elementos sera hacer click en el archivo README.md y en la linea que especifica el tamaño del archivo revisar que debe haber un lápiz al lado de una papelera.
Toquen en el lápiz.
En esa caja de edición debe buscar los corchetes y agregar una x en el medio de ellas

[Más acerca de los temas de Github para markdown](https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown)

# No sienta que no es lo suficientemente capaz
- Los Licenciados en Informática exitosos son inteligentes pero muchos tienen la inseguridad de no ser lo suficientemente listos.
- El super programador que aparece en las películas o series es falso, recuerden eso, sino me creen miren el video de estos empleados de Google.
 [The myth of the Genius Programmer](https://www.youtube.com/watch?v=0SARbwvhupQ)
- Recuerde que no esta solo y su duda no es única, muchas personas tuvieron exactamente los mismos problemas, puede pedir ayuda cuando quiera.
[It's Dangerous to Go Alone: Battling the Invisible Monsters in Tech](https://www.youtube.com/watch?v=1i8ylq4j_EY)
- Es importante que considere que usted pueda mejorar.
[Believe you can change](http://www.aaronsw.com/weblog/dweck)

# Lo que necesita saber
Principalmente la carrera tiene 5 grandes ramas que vendrían siendo aproximadamente el **85%** de la titulación.
- **Matemáticas** (Algebra, Análisis Matemático, Probabilidad y Estadística, etc.)
- **Programación** (Algoritmos y Estructura de Datos, Programación Orientada a Objetos, Interfaces de Usuario y Tecnologías Web, etc.)
- **Electrónica** (Tecnología Aplicada, Arquitectura de Computadores, Comunicación y Redes, etc.)
- **Sistemas** (Teoría de Sistemas y Organizaciones, Ingeniería de Software, Dirección y Evaluación de Proyectos Informáticos, etc.)
- **Lógica** (Matemática Discreta, Lenguajes Formales, Lenguajes de Programación, etc.)

El otro **15%** restante son materias que están para poder obtener la acreditación de la **CONEAU** (*Comisión Nacional de Evaluación y Acreditación Universitaria*).

Antes de adentrarnos en estas materias se tiene que tener consideración que usted debe haber aprobado las siguientes materias del *Curso de Apoyo al Acceso*:
- *Fundamentos de Matemática*
- *Introducción a la Tecnología*
- *Introducción a la Informática*
- *Introducción a la Universidad y a las habilidades*

# Descripción de la Carrera
Se propone formar egresados con significativos fundamentos de Informática y conocimientos actualizado de las tecnologías, lo que permitirá seguir capacitándose permanentemente al ritmo de la evolución tecnológica. Podrá planificar, dirigir, realizar y/o evaluar proyectos de diseño, verificación, puesta a punto, mantenimiento y actualización para redes de comunicaciones que vinculen sistemas de procesamiento de datos. Podrá realizar la especificación del co-diseño hardware-Software y prueba funcional (real o simulada) de la Arquitectura.

El egresado de esta carrera está capacitado para controlar las normas de calidad en el Software o Software integrado a otros componentes y efectuar las tareas de auditoria de los sistemas Informáticos, realizar arbitrajes, peritajes y tasaciones relacionadas con los sistemas Informáticos.

También podrá realizar tareas como docente universitario en Informática en todos los niveles, de acuerdo a la jerarquía de titulo de grado máximo.

# Universidad vs. Realidad
Tras la descripción básica de la carrera que la universidad nos brinda hay que analizar bien el hecho de para que sirve y que sucede a decir de verdad dentro de la misma.
La carrera es extensa, tiene unos buenos premios, 3 títulos, el primero que es recibido tras finalizar segundo año es el certificado de "Diplomado en Informática", tras finalizar todo tercer año se recibe el titulo de "Analista en Informática" y finalizando la carrera "Licenciatura en Informática". Como es sabido en carreras de este tipo con gran carga horaria  y carreras en la que hay que brindar una gran motivación por lo que se hace o se terminan abandonando, el titulo no implica que se pueda conseguir un trabajo bueno.
Explicare los motivos fundamentales:
  - La idea no es ser programador. Si bien hay muchas materias de programación, no significa que salgas siendo programador. El contenido que uno debe saber manejar para ser considerado un buen programador es mucho, mucho más del que cubre la carrera, en la carrera no se ve ni un solo framework, ni front-end ni back-end, se obtiene conceptos importantes para cualquiera que tenga que estar metido en el tema. Temas como la complejidad computacional de un código si son refinados a lo largo de la carrera. A la hora de conseguir un trabajo dependiendo del trabajo a ocupar podrás hacer uso de esta capacidad sin embargo estos trabajos suelen ser la minoria.
  - Hay varias materias basadas en la idea de que nosotros vamos a ser dueños de una PyMES o una startup. No veo mal que existan pero veo mal que se las considere como fundamentales para nuestro titulo.
  - La mayoría de los docentes tienen un desempeño y nivel académico bastante destacable. Esto sin embargo, no influye en la totalidad de las materias. Por un sencillos motivo, algunos docentes están enseñando materias que no son su especificación, años de trabajo en areas relacionadas a la explotación de datos para terminar dando clases de programación orientada a objetos. Obviamente no enseñaría con la misma pasión que si estuvieran en su area.
  - Programación. Lo que sucede con esto es que como he dicho. La programación implica mucho, es un campo que se incrementa la cantidad de información día a día, no basta con lo básico y si de por si lo básico se enseña de forma incompleta es un problema. Principalmente hablo de Algoritmos con esto ultimo, es una materia que como verán más adelante tiene 4 meses para explicar los fundamentos de la programación básica y empieza dedicándole un mes entero a diagramas de flujos, comprendo que pueda necesitarse la idea más adelante. Pero seamos honestos los diagramas no tienen una forma exacta de hacerse, son bastante intuitivos usualmente, lo desees o no nadie usara el mismo sistema de diagramación, seria mucho mejor que se dedique ese mes extra a programar en el lenguaje que se enseña en esa materia, C. Lo digo por el hecho de que la co-relatividad en este apartado es ... raro... tienen que dar como base un concepto muy importante llamado estructuras para poder finalizar la materia, de esa forma los que hayan aprobado se les sera más fácil comprender lo que son objetos. Pero no, el tema no es enseñado y ni siquiera es nombrado, por lo cual conlleva que el estudiante que nunca decidió buscar por su cuenta las especificaciones del lenguaje o estudio otro lenguaje de programación el concepto de objetos sea muy abstracto para ellos.
  - El programa. El contenido de la materia es el mismo pero dependiendo de con que profesor curses el programa es demasiado flexible, puedes empezar por ejemplo las clases de Programación Orientada a Objetos teniendo una actividad que implica usar la herencia y leer archivos sin explicar los fundamentos de la orientación a objetos, que es herencia o por lo menos como funciona el lenguaje de programación. Este ejemplo que doy es muy discutido por alumnos lamentablemente pero es unicamente bajo este tipo de materias en las que sucede por lo que comentan todos.

En definitiva la carrera tiene problemas, eso esta más que asumido pero en definitiva es una carrera complicada, dudo mucho que haya una universidad que sepa abordar bien todos los temas que deberían verse a lo largo del plazo estudiantil para asegurar que el alumnado consiga un empleo con unicamente visto en las cursadas. Al menos en el campo de la programación.
Por lo que considero que la carrera es buena, la enseñan bastante bien, hay casos por supuesto que se hace notar muy fácilmente que algo no funciona.
Pero siendo sincero eso ocurre en todos lados, no unicamente en esta universidad.
Es importante aclarar esto ya que la idea no es que te formes como Informático en si, sino quiero entender de que es una orientación para ser Investigador en el campo, muchos temas no se van a conseguir a ver pero por un hecho que es imposible, en algunos empleos piden que uno sea un programador Senior y eso se consigue tras casi 8 años de trabajar en un mismo entorno. A lo sumos habrá post-grados pero **es imposible que la carrera abarque todas las ramas de forma detallada** y todas las posibilidades de esta materia tan compleja como lo es la Informática.
Por eso se enseñan las bases de todo, para que a partir de esas bases se logre investigar y comprender de manera más sencilla el resto del contenido por más que no haya sido enseñado durante alguna materia.

Si tu idea es hacer la carrera y estudiar el programa con la idea de que vas a conseguir trabajo unicamente con esto puede que no sea así, puede que haya contenido de más o contenido faltante. Depende de lo que se este buscando pero en general **la carrera es lo suficientemente buena como para explicar un poco de todo**.

# Antes de iniciar

Esta lista creció a lo largo de varios meses, y sí, está un poco fuera de las manos.

Aquí algunos de mis errores para que pueda tener una mejor experiencia.

## 1. No recordará todo

Vi horas de video y tomé notas exactas de ellos, meses después había mucho que no recordaba. Pase tres días entre mis notas y haciendo tarjetas para poder repasar.

Me han preguntado muchas veces:

    ¿Cómo recuerdas todas las cosas que has estado estudiando?

Este es mi método que mantendrá todas las cosas buenas en tu cerebro.

### Mi error al principio
Cuando comencé a estudiar los fundamentos de la programación, miraba videos todo el día, tomaba toneladas de notas e intentaba recordar. También pasé tiempo implementando estructuras de datos y sus algoritmos asociados.

Con el tiempo, me di cuenta de que estaba olvidando cosas. No estaba revisando mis notas y sentí que todas las horas que invertí en ver videos fueron en su mayoría desperdiciadas.

### Repetición a lo largo del tiempo
Lo que **debería haber hecho** para cada tema:
- Mirar un par de horas de videos sobre el tema, para obtener la idea principal
- Implementar lo aprendido
- Crear tarjetas de memoria para cosas importantes que debo recordar sobre el tema
- **Pasar al siguiente tema**
- Repasar las tarjetas cuando tenia tiempo
- Después de unos días, ver otro video sobre el tema, tal vez 30 minutos más o menos después de otra semana, ver un video sobre el tema, tal vez el mismo video o uno más corto.
- Seguir revisando tarjetas de memoria

Lo que hay que notar aquí es la repetición. Pasar uno o dos días mirando videos sobre un tema simplemente refuerza lo que aprendió recientemente en las últimas horas. Esto no es un fuerte refuerzo del conocimiento. Te olvidarás.

Repasar todas mis notas y las pongo en tarjetas de memoria. **Muchas, muchas (demasiadas)** tarjetas recorda memorias.
Debería haber un intervalo de tiempo entre aprender algo por primera vez y revisarlo más tarde.

El punto importante es: **revisar un tema en varios intervalos de tiempo**. Seguir reforzándote y recordándote, y no lo olvidarás. El intervalo de tiempo puede ser más largo con el tiempo. Esto se llama "**[repaso espaciado](https://es.wikipedia.org/wiki/Repaso_espaciado)**".

Esto es esencial para aprobar algunas materias. Hablo de ti **Algebra**.

## 2. Use tarjetas para recordar
Para solucionar el problema de las tarjetas recomiendo:
- El uso exhaustivo de programas que cumplan bien la función de paquetes de Ofimática (Microsoft Word, OpenOffice, LibreOffice, WPS Office, etc.) o editores gráficos (Adobe Photoshop, Paint Tool SAI, Krita, GIMP, antes que preguntes... Si... Microsoft Paint también cuenta), la idea es sencilla.
Haces anotaciones, archivos que sean simples de ver, que tu los entiendas. Pero que sean portables ¿A que me refiero? Que cuando lo pases a tu celular no te encuentres con un problema como:

      Demonios mi celular no lee el archivo

    Por eso recomiendo los formatos PDF y PNG para hacer una tarjeta. Son portables y no muy complicados de editar. Cualquier celular moderno los abre independientemente del sistema operativo que use.

- Todo lo que hagas subirlo a internet.
  Privado o publico no importa mientras que lo subas a internet.

El sentido de esto es usarlo en cualquier momento, cuando estas viajando, cuando estas esperando algo, lo que sea siempre tendrás tus apuntes a mano.
Tienes un problema con el celular, la computadora, siempre estará la versión en la nube disponible por suerte. Es por eso que todo lo que hagamos recomiendo tenerlo subido a internet.

Cada tarjeta puede tener distinto formato pero lo importante es que sus anotaciones las pueda entender de principio a fin.

## 3. Enfóquese

Hay muchas distracciones le pueden quitar tiempo valioso. Enfocarse y concentrarse es difícil.
**¡Lo digo por experiencia!** (Y mucha...).

# Primer Año

## Algoritmos y Estructura de Datos
La materia como se divide principalmente en dos aspectos fundamentales se basara en eso este repositorio. Los mismos son **Diagrama de Flujo** y **Programación en C**.
Habrá 2 evaluaciones y 1 trabajo practico que se deberá entregar en una primera instancia y se habrá que modificar un par de semanas después considerándolo una segunda parte del trabajo practico.

Siendo la primera materia de programación dentro de la carrera se explicara con diagrama de flujo los conceptos de entrada, salida, variables, condiciones, jerarquía matemática y ciclos(Exceptuando el bucle For Each).

_Tras pasado un mes aproximadamente tomaran un parcial de Diagrama de flujo._

Posiblemente lo más complicado que puedan evaluar ese primer examen es el realizar una algoritmo en el cual se retire una cantidad de dinero, el mismo mostrara un mensaje cuando ya no haya dinero y posiblemente hace al finalizar el algoritmo habría que entregar un mensaje diciendo cuales fueron las transacciones de mayor dinero y las de menor dinero.
___
Tras llegar empezada la segunda parte de la materia empezaran a ver el [lenguaje de programación C](https://es.wikipedia.org/wiki/C_(lenguaje_de_programaci%C3%B3n).
Se explicara el como definir una constante, incluir una librería, declarar una variable, hacer uso de la sintaxis del if, else, switch, while, do while, for, se explica el uso de las referencias y los punteros, la idea básica de vectores, matrices y de la programación funcional.
Se trabajara además de la librería stdio con la librería conio, string y math.
*No obstante no se contempla ni el concepto de estructura, ni de memoria dinamica.*


____
Actividades:
[Actividades de Algoritmos - UNO - 2016](https://github.com/Phosphorus-M/Study-program-of-the-UNO-Universidad-Nacional-del-Oeste-/tree/master/activitys)

Material Didáctico extra:
[Introducción a los Lenguajes de Programación - DesarrolloWeb](https://youtu.be/QIMhN4fzyYE)
[Variables y Tipos de Datos - DesarrolloWeb](https://youtu.be/W4DY3ZspLC4) [VIDEO]
[Algoritmo - Fundamentos de la programacion - DesarrolloWeb](https://youtu.be/YFdXfehe2bo) [VIDEO]
[Alternativas y repeticiones - DesarrolloWeb](https://youtu.be/JwZT8L-0_gU) [VIDEO]
[Repeticiones, bucles - DesarrolloWeb](https://youtu.be/L8HGNuKrvJo) [VIDEO]
[Subprogramación - DesarrolloWeb](https://youtu.be/dHwoi6FXOEs) [VIDEO]
[Desarrollando en C - makigas](https://www.youtube.com/playlist?list=PLTd5ehIj0goMZ33qJ7JmuXjSO8RoefiZS) [VIDEO]
[Tutorial de C - makigas](https://www.youtube.com/channel/UCQufRmIMRTLdRxTsXCh4-5w)
[Programación desde cero con Diagramas de Flujo - Programación ATS](https://www.youtube.com/playlist?list=PLWtYZ2ejMVJnpjQFWykrPcVOycJLVP2cG) [VIDEO]
[Aprende Programación en C - Programación ATS](https://www.youtube.com/playlist?list=PLWtYZ2ejMVJmUTNE2QVaCd1y_6GslOeZ6) [VIDEO]
[Algoritmos en PSeInt - Programación ATS](https://www.youtube.com/playlist?list=PLWtYZ2ejMVJlACGFXj4zpJ8cWdSjF05tm) [VIDEO]
[Practice-c - jwasham](https://github.com/jwasham/practice-c) [CÓDIGO]
